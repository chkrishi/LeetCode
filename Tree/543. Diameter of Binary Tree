#My solution, but failed in cases where they shared a common path as common path is considered as 0
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        def rightval(rootval: Optional[TreeNode], n: int) -> None:
            if not rootval:
                return 
            elif rootval.left is None and rootval.right is None:
                rarr.append(n)
                n -= 1
            elif rootval.right is None and rootval.left:
                rightval(rootval.left,n)
            else:
                n += 1
                rightval(rootval.right,n)
        def leftval(rootval: Optional[TreeNode],m : int)-> None:
            if not rootval:
                return 
            elif rootval.left is None and rootval.right is None:
                larr.append(m)
                m -= 1
            elif rootval.left is None and rootval.right:
                leftval(rootval.right,m)
            else:
                m += 1
                leftval(rootval.left,m)
        n,m = 0,0
        larr,rarr = [],[]
        rightval(root,n)
        leftval(root,m)
        return max(larr) + max(rarr) 
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________
#Found in solutions section

class Solution:
    def __init__(self):
	    self.diameter = 0
	
    def depth(self, node: Optional[TreeNode]) -> int:
        if not node:
            return 0
        left = self.depth(node.left) 
        right = self.depth(node.right)
        self.diameter = max(self.diameter, left + right)
        return 1 + max(left, right)
    
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        self.depth(root)
        return self.diameter
