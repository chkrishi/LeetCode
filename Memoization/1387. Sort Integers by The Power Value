#My own soln --> Accepted, but there is a better solution
class Solution:
    def getKth(self, lo: int, hi: int, k: int) -> int:
        arr = []
        setval = {}
        temp = lo
        while temp <= hi:
            x = temp
            count = 0
            while x != 1:
                if x in setval:
                    count += setval[x]
                    break
                if x % 2 == 0:
                    x = x // 2     
                else:
                    x = 3 * x + 1
                count += 1

            setval[temp] = count
            arr.append([count, temp])
            temp += 1

        arr = sorted(arr, key=lambda x: (x[0], x[1]))
        return arr[k - 1][1]

________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

class Solution:
    def getKth(self, lo: int, hi: int, k: int) -> int:
        power_cache = {}

        def get_power(x):
            if x == 1:
                return 0
            if x in power_cache:
                return power_cache[x]
            if x % 2 == 0:
                power_cache[x] = 1 + get_power(x // 2)
            else:
                power_cache[x] = 1 + get_power(3 * x + 1)
            return power_cache[x]

        arr = []
        for num in range(lo, hi + 1):
            arr.append((get_power(num), num))

        # Sort by power first, then by the number itself
        arr.sort(key=lambda x: (x[0], x[1]))

        # Return the kth number (1-indexed)
        return arr[k - 1][1]
